<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Modulo: modulo::core::Cell Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Modulo
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>modulo</b></li><li class="navelem"><b>core</b></li><li class="navelem"><a class="el" href="classmodulo_1_1core_1_1_cell.html">Cell</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classmodulo_1_1core_1_1_cell-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">modulo::core::Cell Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract class to define a <a class="el" href="classmodulo_1_1core_1_1_cell.html" title="Abstract class to define a Cell A Cell is the base class of the whole architecture. It handles all the basic ROS communications such as definitions of subscriptions, publishers and service calls. It can then be derived into a MotionGenerator, a Controller, a Sensor, or a RobotInterface. It is derived from a lifecycle node which allows to use ROS2 state machine functionalities for nodes. ">Cell</a> A <a class="el" href="classmodulo_1_1core_1_1_cell.html" title="Abstract class to define a Cell A Cell is the base class of the whole architecture. It handles all the basic ROS communications such as definitions of subscriptions, publishers and service calls. It can then be derived into a MotionGenerator, a Controller, a Sensor, or a RobotInterface. It is derived from a lifecycle node which allows to use ROS2 state machine functionalities for nodes. ">Cell</a> is the base class of the whole architecture. It handles all the basic ROS communications such as definitions of subscriptions, publishers and service calls. It can then be derived into a MotionGenerator, a Controller, a Sensor, or a RobotInterface. It is derived from a lifecycle node which allows to use ROS2 state machine functionalities for nodes.  
 <a href="classmodulo_1_1core_1_1_cell.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for modulo::core::Cell:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmodulo_1_1core_1_1_cell.png" usemap="#modulo::core::Cell_map" alt=""/>
  <map id="modulo::core::Cell_map" name="modulo::core::Cell_map">
<area href="classmodulo_1_1core_1_1_component.html" title="Abstract class to define an component, handling base predicates. " alt="modulo::core::Component" shape="rect" coords="0,112,153,136"/>
<area href="classmodulo_1_1core_1_1_monitor.html" title="Abstract class to define a Monitor. " alt="modulo::core::Monitor" shape="rect" coords="163,112,316,136"/>
<area href="classmodulo_1_1core_1_1_recorder.html" title="Abstract class to define a Recorder A Recorder is used to listen on specific topics and record the re..." alt="modulo::core::Recorder" shape="rect" coords="326,112,479,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6f54f87fdeab9b58624f41a8c36c325c"><td class="memTemplParams" colspan="2">template&lt;typename DurationT &gt; </td></tr>
<tr class="memitem:a6f54f87fdeab9b58624f41a8c36c325c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a6f54f87fdeab9b58624f41a8c36c325c">Cell</a> (const std::string &amp;node_name, const std::chrono::duration&lt; int64_t, DurationT &gt; &amp;period, bool intra_process_comms=false)</td></tr>
<tr class="memdesc:a6f54f87fdeab9b58624f41a8c36c325c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmodulo_1_1core_1_1_cell.html" title="Abstract class to define a Cell A Cell is the base class of the whole architecture. It handles all the basic ROS communications such as definitions of subscriptions, publishers and service calls. It can then be derived into a MotionGenerator, a Controller, a Sensor, or a RobotInterface. It is derived from a lifecycle node which allows to use ROS2 state machine functionalities for nodes. ">Cell</a> constructor with arguments needed from ROS2 node.  <a href="#a6f54f87fdeab9b58624f41a8c36c325c">More...</a><br /></td></tr>
<tr class="separator:a6f54f87fdeab9b58624f41a8c36c325c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4de79f0ad4ecfab5dc8622b25435fc5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#ab4de79f0ad4ecfab5dc8622b25435fc5">Cell</a> (const rclcpp::NodeOptions &amp;options)</td></tr>
<tr class="memdesc:ab4de79f0ad4ecfab5dc8622b25435fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmodulo_1_1core_1_1_cell.html" title="Abstract class to define a Cell A Cell is the base class of the whole architecture. It handles all the basic ROS communications such as definitions of subscriptions, publishers and service calls. It can then be derived into a MotionGenerator, a Controller, a Sensor, or a RobotInterface. It is derived from a lifecycle node which allows to use ROS2 state machine functionalities for nodes. ">Cell</a> construction from ROS2 NodeOptions.  <a href="#ab4de79f0ad4ecfab5dc8622b25435fc5">More...</a><br /></td></tr>
<tr class="separator:ab4de79f0ad4ecfab5dc8622b25435fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb5a7c6af8968f23ffa69ec1a314522"><td class="memItemLeft" align="right" valign="top"><a id="adcb5a7c6af8968f23ffa69ec1a314522"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#adcb5a7c6af8968f23ffa69ec1a314522">~Cell</a> ()</td></tr>
<tr class="memdesc:adcb5a7c6af8968f23ffa69ec1a314522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:adcb5a7c6af8968f23ffa69ec1a314522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13211781282916bdcd836289088f729"><td class="memItemLeft" align="right" valign="top">const std::chrono::nanoseconds &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#af13211781282916bdcd836289088f729">get_period</a> () const</td></tr>
<tr class="memdesc:af13211781282916bdcd836289088f729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter of the period attribute.  <a href="#af13211781282916bdcd836289088f729">More...</a><br /></td></tr>
<tr class="separator:af13211781282916bdcd836289088f729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3474ece0416029d4f404af1b2910c1d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a3474ece0416029d4f404af1b2910c1d6">is_configured</a> () const</td></tr>
<tr class="memdesc:a3474ece0416029d4f404af1b2910c1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter of the configured boolean attribute.  <a href="#a3474ece0416029d4f404af1b2910c1d6">More...</a><br /></td></tr>
<tr class="separator:a3474ece0416029d4f404af1b2910c1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace47d79114cbba0fd4d84088df49a1ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#ace47d79114cbba0fd4d84088df49a1ea">is_active</a> () const</td></tr>
<tr class="memdesc:ace47d79114cbba0fd4d84088df49a1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter of the active boolean attribute.  <a href="#ace47d79114cbba0fd4d84088df49a1ea">More...</a><br /></td></tr>
<tr class="separator:ace47d79114cbba0fd4d84088df49a1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6cd4b8d5d95ee9df36963902f1dbc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#aca6cd4b8d5d95ee9df36963902f1dbc1">is_shutdown</a> () const</td></tr>
<tr class="memdesc:aca6cd4b8d5d95ee9df36963902f1dbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter of the shutdown boolean attribute.  <a href="#aca6cd4b8d5d95ee9df36963902f1dbc1">More...</a><br /></td></tr>
<tr class="separator:aca6cd4b8d5d95ee9df36963902f1dbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db583f79249081e49dcd5867801a1da"><td class="memTemplParams" colspan="2">template&lt;typename MsgT , class RecT , typename DurationT &gt; </td></tr>
<tr class="memitem:a9db583f79249081e49dcd5867801a1da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a9db583f79249081e49dcd5867801a1da">add_publisher</a> (const std::string &amp;channel, const std::shared_ptr&lt; RecT &gt; &amp;recipient, const std::chrono::duration&lt; int64_t, DurationT &gt; &amp;period, bool always_active=false, int queue_size=10)</td></tr>
<tr class="memdesc:a9db583f79249081e49dcd5867801a1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to add a generic publisher to the map of handlers.  <a href="#a9db583f79249081e49dcd5867801a1da">More...</a><br /></td></tr>
<tr class="separator:a9db583f79249081e49dcd5867801a1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29cfa3a50c8e5dff204d8d3a77bbfdd"><td class="memTemplParams" colspan="2">template&lt;typename MsgT , class RecT &gt; </td></tr>
<tr class="memitem:ad29cfa3a50c8e5dff204d8d3a77bbfdd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#ad29cfa3a50c8e5dff204d8d3a77bbfdd">add_publisher</a> (const std::string &amp;channel, const std::shared_ptr&lt; RecT &gt; &amp;recipient, bool always_active=false, int queue_size=10)</td></tr>
<tr class="memdesc:ad29cfa3a50c8e5dff204d8d3a77bbfdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to add a generic publisher to the map of handlers.  <a href="#ad29cfa3a50c8e5dff204d8d3a77bbfdd">More...</a><br /></td></tr>
<tr class="separator:ad29cfa3a50c8e5dff204d8d3a77bbfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7606dc7a4d36f1f8bb8e4011087a7d"><td class="memTemplParams" colspan="2">template&lt;class RecT , typename DurationT &gt; </td></tr>
<tr class="memitem:a5e7606dc7a4d36f1f8bb8e4011087a7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a5e7606dc7a4d36f1f8bb8e4011087a7d">add_state_publisher</a> (const std::string &amp;channel, const std::shared_ptr&lt; RecT &gt; &amp;recipient, const std::chrono::duration&lt; int64_t, DurationT &gt; &amp;period, bool always_active=false, int queue_size=10)</td></tr>
<tr class="memdesc:a5e7606dc7a4d36f1f8bb8e4011087a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to add a specific state publisher that makes use of protobuf encodings to the map of handlers.  <a href="#a5e7606dc7a4d36f1f8bb8e4011087a7d">More...</a><br /></td></tr>
<tr class="separator:a5e7606dc7a4d36f1f8bb8e4011087a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb76634b4d55866ee751127082906c9"><td class="memTemplParams" colspan="2">template&lt;class RecT &gt; </td></tr>
<tr class="memitem:adbb76634b4d55866ee751127082906c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#adbb76634b4d55866ee751127082906c9">add_state_publisher</a> (const std::string &amp;channel, const std::shared_ptr&lt; RecT &gt; &amp;recipient, bool always_active=false, int queue_size=10)</td></tr>
<tr class="memdesc:adbb76634b4d55866ee751127082906c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to add a specific state publisher that makes use of protobuf encodings to the map of handlers.  <a href="#adbb76634b4d55866ee751127082906c9">More...</a><br /></td></tr>
<tr class="separator:adbb76634b4d55866ee751127082906c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7389de153da8a35b50ee7c089a806b4a"><td class="memTemplParams" colspan="2">template&lt;typename MsgT , class RecT , typename DurationT &gt; </td></tr>
<tr class="memitem:a7389de153da8a35b50ee7c089a806b4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a7389de153da8a35b50ee7c089a806b4a">add_subscription</a> (const std::string &amp;channel, const std::shared_ptr&lt; RecT &gt; &amp;recipient, const std::chrono::duration&lt; int64_t, DurationT &gt; &amp;timeout, bool always_active=false, int queue_size=10)</td></tr>
<tr class="memdesc:a7389de153da8a35b50ee7c089a806b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to add a generic subscription to the map of handlers.  <a href="#a7389de153da8a35b50ee7c089a806b4a">More...</a><br /></td></tr>
<tr class="separator:a7389de153da8a35b50ee7c089a806b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f36681d56926a2e6d091953f337eb7"><td class="memTemplParams" colspan="2">template&lt;typename MsgT , class RecT &gt; </td></tr>
<tr class="memitem:ab3f36681d56926a2e6d091953f337eb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#ab3f36681d56926a2e6d091953f337eb7">add_subscription</a> (const std::string &amp;channel, const std::shared_ptr&lt; RecT &gt; &amp;recipient, bool always_active=false, unsigned int nb_period_to_timeout=10, int queue_size=10)</td></tr>
<tr class="memdesc:ab3f36681d56926a2e6d091953f337eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to add a generic subscription to the map of handlers.  <a href="#ab3f36681d56926a2e6d091953f337eb7">More...</a><br /></td></tr>
<tr class="separator:ab3f36681d56926a2e6d091953f337eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95ae271520a43ff6cebfee4dcc3ca8c"><td class="memTemplParams" colspan="2">template&lt;class RecT , typename DurationT &gt; </td></tr>
<tr class="memitem:ad95ae271520a43ff6cebfee4dcc3ca8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#ad95ae271520a43ff6cebfee4dcc3ca8c">add_state_subscription</a> (const std::string &amp;channel, const std::shared_ptr&lt; RecT &gt; &amp;recipient, const std::chrono::duration&lt; int64_t, DurationT &gt; &amp;timeout, bool always_active=false, int queue_size=10)</td></tr>
<tr class="memdesc:ad95ae271520a43ff6cebfee4dcc3ca8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to add a specific state subscription that makes use of protobuf decoding to the map of handlers.  <a href="#ad95ae271520a43ff6cebfee4dcc3ca8c">More...</a><br /></td></tr>
<tr class="separator:ad95ae271520a43ff6cebfee4dcc3ca8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fee86d69a6a08d16f3e3e81b526522"><td class="memTemplParams" colspan="2">template&lt;class RecT &gt; </td></tr>
<tr class="memitem:a20fee86d69a6a08d16f3e3e81b526522"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a20fee86d69a6a08d16f3e3e81b526522">add_state_subscription</a> (const std::string &amp;channel, const std::shared_ptr&lt; RecT &gt; &amp;recipient, bool always_active=false, unsigned int nb_period_to_timeout=10, int queue_size=10)</td></tr>
<tr class="memdesc:a20fee86d69a6a08d16f3e3e81b526522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to add a specific state subscription that makes use of protobuf decoding to the map of handlers.  <a href="#a20fee86d69a6a08d16f3e3e81b526522">More...</a><br /></td></tr>
<tr class="separator:a20fee86d69a6a08d16f3e3e81b526522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f0168a5774facb8660e8527d4827a9"><td class="memTemplParams" colspan="2">template&lt;typename srvT , typename DurationT &gt; </td></tr>
<tr class="memitem:a38f0168a5774facb8660e8527d4827a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a38f0168a5774facb8660e8527d4827a9">add_client</a> (const std::string &amp;channel, const std::chrono::duration&lt; int64_t, DurationT &gt; &amp;timeout)</td></tr>
<tr class="memdesc:a38f0168a5774facb8660e8527d4827a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to add a generic client to the map of handlers.  <a href="#a38f0168a5774facb8660e8527d4827a9">More...</a><br /></td></tr>
<tr class="separator:a38f0168a5774facb8660e8527d4827a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4927517bf0bc8b94d6cb5decefb823b"><td class="memTemplParams" colspan="2">template&lt;typename DurationT &gt; </td></tr>
<tr class="memitem:ae4927517bf0bc8b94d6cb5decefb823b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#ae4927517bf0bc8b94d6cb5decefb823b">add_transform_broadcaster</a> (const std::shared_ptr&lt; state_representation::CartesianState &gt; &amp;recipient, const std::chrono::duration&lt; int64_t, DurationT &gt; &amp;period, bool always_active=false, int queue_size=10)</td></tr>
<tr class="memdesc:ae4927517bf0bc8b94d6cb5decefb823b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add a generic transform broadcaster to the map of handlers.  <a href="#ae4927517bf0bc8b94d6cb5decefb823b">More...</a><br /></td></tr>
<tr class="separator:ae4927517bf0bc8b94d6cb5decefb823b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93af246ceb62834fba40ae7e196a4f6f"><td class="memTemplParams" colspan="2">template&lt;typename DurationT &gt; </td></tr>
<tr class="memitem:a93af246ceb62834fba40ae7e196a4f6f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a93af246ceb62834fba40ae7e196a4f6f">add_transform_broadcaster</a> (const state_representation::CartesianPose &amp;recipient, const std::chrono::duration&lt; int64_t, DurationT &gt; &amp;period, bool always_active=false, int queue_size=10)</td></tr>
<tr class="memdesc:a93af246ceb62834fba40ae7e196a4f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add a generic transform broadcaster to the map of handlers.  <a href="#a93af246ceb62834fba40ae7e196a4f6f">More...</a><br /></td></tr>
<tr class="separator:a93af246ceb62834fba40ae7e196a4f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d6de7a100ec206d253fb5c464568bb"><td class="memTemplParams" colspan="2">template&lt;typename DurationT &gt; </td></tr>
<tr class="memitem:a33d6de7a100ec206d253fb5c464568bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a33d6de7a100ec206d253fb5c464568bb">add_transform_broadcaster</a> (const std::shared_ptr&lt; state_representation::ParameterInterface &gt; &amp;recipient, const std::chrono::duration&lt; int64_t, DurationT &gt; &amp;period, bool always_active=false, int queue_size=10)</td></tr>
<tr class="memdesc:a33d6de7a100ec206d253fb5c464568bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add a generic transform broadcaster to the map of handlers.  <a href="#a33d6de7a100ec206d253fb5c464568bb">More...</a><br /></td></tr>
<tr class="separator:a33d6de7a100ec206d253fb5c464568bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1715e6ba3c3976921f4e6d92284d7369"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a1715e6ba3c3976921f4e6d92284d7369">add_transform_broadcaster</a> (const std::shared_ptr&lt; state_representation::CartesianState &gt; &amp;recipient, bool always_active=false, int queue_size=10)</td></tr>
<tr class="memdesc:a1715e6ba3c3976921f4e6d92284d7369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add a generic transform broadcaster to the map of handlers.  <a href="#a1715e6ba3c3976921f4e6d92284d7369">More...</a><br /></td></tr>
<tr class="separator:a1715e6ba3c3976921f4e6d92284d7369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac069bec4807a256f2473b41d5625fc14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#ac069bec4807a256f2473b41d5625fc14">add_transform_broadcaster</a> (const state_representation::CartesianPose &amp;recipient, bool always_active=false, int queue_size=10)</td></tr>
<tr class="memdesc:ac069bec4807a256f2473b41d5625fc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add a generic transform broadcaster to the map of handlers.  <a href="#ac069bec4807a256f2473b41d5625fc14">More...</a><br /></td></tr>
<tr class="separator:ac069bec4807a256f2473b41d5625fc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a1fcc562c8ac09b6bad98e080915e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a25a1fcc562c8ac09b6bad98e080915e2">add_transform_broadcaster</a> (const std::shared_ptr&lt; state_representation::ParameterInterface &gt; &amp;recipient, bool always_active=false, int queue_size=10)</td></tr>
<tr class="memdesc:a25a1fcc562c8ac09b6bad98e080915e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add a generic transform broadcaster to the map of handlers.  <a href="#a25a1fcc562c8ac09b6bad98e080915e2">More...</a><br /></td></tr>
<tr class="separator:a25a1fcc562c8ac09b6bad98e080915e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aea311b40f849bde13cbd343fbc35be"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7aea311b40f849bde13cbd343fbc35be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a7aea311b40f849bde13cbd343fbc35be">add_parameter</a> (const std::shared_ptr&lt; state_representation::Parameter&lt; T &gt;&gt; &amp;parameter, const std::string &amp;prefix=&quot;&quot;)</td></tr>
<tr class="memdesc:a7aea311b40f849bde13cbd343fbc35be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a parameter to be updated by the parameter server.  <a href="#a7aea311b40f849bde13cbd343fbc35be">More...</a><br /></td></tr>
<tr class="separator:a7aea311b40f849bde13cbd343fbc35be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fd1167640d8de301c9f69323a493c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a51fd1167640d8de301c9f69323a493c4">add_parameters</a> (const std::list&lt; std::shared_ptr&lt; state_representation::ParameterInterface &gt;&gt; &amp;parameters, const std::string &amp;prefix=&quot;&quot;)</td></tr>
<tr class="memdesc:a51fd1167640d8de301c9f69323a493c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add multiple parameters to be updated by the parameter server.  <a href="#a51fd1167640d8de301c9f69323a493c4">More...</a><br /></td></tr>
<tr class="separator:a51fd1167640d8de301c9f69323a493c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6e888001df99c8201dc728709d05ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee6e888001df99c8201dc728709d05ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#aee6e888001df99c8201dc728709d05ae">set_parameter_value</a> (const std::string &amp;parameter_name, const T &amp;value)</td></tr>
<tr class="memdesc:aee6e888001df99c8201dc728709d05ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a declared parameter.  <a href="#aee6e888001df99c8201dc728709d05ae">More...</a><br /></td></tr>
<tr class="separator:aee6e888001df99c8201dc728709d05ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c491b299de1d33d8f32389cdfd5c9b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56c491b299de1d33d8f32389cdfd5c9b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a56c491b299de1d33d8f32389cdfd5c9b">set_parameter_value</a> (const std::shared_ptr&lt; state_representation::Parameter&lt; T &gt;&gt; &amp;parameter)</td></tr>
<tr class="memdesc:a56c491b299de1d33d8f32389cdfd5c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a declared parameter.  <a href="#a56c491b299de1d33d8f32389cdfd5c9b">More...</a><br /></td></tr>
<tr class="separator:a56c491b299de1d33d8f32389cdfd5c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948e1b5a2a7fa1a36d4f6cdf6e7eb7a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a948e1b5a2a7fa1a36d4f6cdf6e7eb7a1">set_parameter_value</a> (const std::shared_ptr&lt; state_representation::ParameterInterface &gt; &amp;parameter)</td></tr>
<tr class="memdesc:a948e1b5a2a7fa1a36d4f6cdf6e7eb7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a declared parameter.  <a href="#a948e1b5a2a7fa1a36d4f6cdf6e7eb7a1">More...</a><br /></td></tr>
<tr class="separator:a948e1b5a2a7fa1a36d4f6cdf6e7eb7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f26e56b46a72d381cd78aff188b7bcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a3f26e56b46a72d381cd78aff188b7bcb">send_transform</a> (const state_representation::CartesianState &amp;transform, const std::string &amp;name=&quot;&quot;) const</td></tr>
<tr class="memdesc:a3f26e56b46a72d381cd78aff188b7bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to send a transform using the generic transform broadcaster.  <a href="#a3f26e56b46a72d381cd78aff188b7bcb">More...</a><br /></td></tr>
<tr class="separator:a3f26e56b46a72d381cd78aff188b7bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b911abe115972016e13913d6349d84e"><td class="memTemplParams" colspan="2">template&lt;typename srvT &gt; </td></tr>
<tr class="memitem:a2b911abe115972016e13913d6349d84e"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; typename srvT::Response &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a2b911abe115972016e13913d6349d84e">send_blocking_request</a> (const std::string &amp;channel, const std::shared_ptr&lt; typename srvT::Request &gt; &amp;request)</td></tr>
<tr class="memdesc:a2b911abe115972016e13913d6349d84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a request to the server and wait for its response.  <a href="#a2b911abe115972016e13913d6349d84e">More...</a><br /></td></tr>
<tr class="separator:a2b911abe115972016e13913d6349d84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be9304077256da63314cb715cf66a1e"><td class="memTemplParams" colspan="2">template&lt;typename srvT &gt; </td></tr>
<tr class="memitem:a8be9304077256da63314cb715cf66a1e"><td class="memTemplItemLeft" align="right" valign="top">std::shared_future&lt; std::shared_ptr&lt; typename srvT::Response &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a8be9304077256da63314cb715cf66a1e">send_request</a> (const std::string &amp;channel, const std::shared_ptr&lt; typename srvT::Request &gt; &amp;request)</td></tr>
<tr class="memdesc:a8be9304077256da63314cb715cf66a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a request to the server without waiting for its response.  <a href="#a8be9304077256da63314cb715cf66a1e">More...</a><br /></td></tr>
<tr class="separator:a8be9304077256da63314cb715cf66a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d57545c240e5f2fec3376dbbb11799"><td class="memItemLeft" align="right" valign="top">const state_representation::CartesianPose&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a11d57545c240e5f2fec3376dbbb11799">lookup_transform</a> (const std::string &amp;frame_name, const std::string &amp;reference_frame=&quot;world&quot;) const</td></tr>
<tr class="memdesc:a11d57545c240e5f2fec3376dbbb11799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get a transform from the generic transform listener.  <a href="#a11d57545c240e5f2fec3376dbbb11799">More...</a><br /></td></tr>
<tr class="separator:a11d57545c240e5f2fec3376dbbb11799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dbc3e1a144545b150b76022a906923"><td class="memItemLeft" align="right" valign="top"><a id="a68dbc3e1a144545b150b76022a906923"></a>
rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a68dbc3e1a144545b150b76022a906923">on_configure</a> (const rclcpp_lifecycle::State &amp;) override</td></tr>
<tr class="memdesc:a68dbc3e1a144545b150b76022a906923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition callback for state configuring on_configure callback is being called when the lifecycle node enters the "configuring" state. Depending on the return value of this function, the state machine either invokes a transition to the "inactive" state or stays in "unconfigured". TRANSITION_CALLBACK_SUCCESS transitions to "inactive" TRANSITION_CALLBACK_FAILURE transitions to "unconfigured" TRANSITION_CALLBACK_ERROR or any uncaught exceptions to "errorprocessing". <br /></td></tr>
<tr class="separator:a68dbc3e1a144545b150b76022a906923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9ccd1a59a1458f2f72381ef1839a6a"><td class="memItemLeft" align="right" valign="top"><a id="aba9ccd1a59a1458f2f72381ef1839a6a"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#aba9ccd1a59a1458f2f72381ef1839a6a">on_configure</a> ()</td></tr>
<tr class="memdesc:aba9ccd1a59a1458f2f72381ef1839a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy function for the on_configure ROS2 lifecycle function. This function is called by the main on_configure function and is made to adapted to the derived class. <br /></td></tr>
<tr class="separator:aba9ccd1a59a1458f2f72381ef1839a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31487d6c266215f51f9bec2461555c4e"><td class="memItemLeft" align="right" valign="top"><a id="a31487d6c266215f51f9bec2461555c4e"></a>
rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a31487d6c266215f51f9bec2461555c4e">on_activate</a> (const rclcpp_lifecycle::State &amp;) override</td></tr>
<tr class="memdesc:a31487d6c266215f51f9bec2461555c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition callback for state activating on_activate callback is being called when the lifecycle node enters the "activating" state. Depending on the return value of this function, the state machine either invokes a transition to the "active" state or stays in "inactive". TRANSITION_CALLBACK_SUCCESS transitions to "active" TRANSITION_CALLBACK_FAILURE transitions to "inactive" TRANSITION_CALLBACK_ERROR or any uncaught exceptions to "errorprocessing". <br /></td></tr>
<tr class="separator:a31487d6c266215f51f9bec2461555c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e4c6f0ee0338d60bbdd805bfd83461"><td class="memItemLeft" align="right" valign="top"><a id="ae0e4c6f0ee0338d60bbdd805bfd83461"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#ae0e4c6f0ee0338d60bbdd805bfd83461">on_activate</a> ()</td></tr>
<tr class="memdesc:ae0e4c6f0ee0338d60bbdd805bfd83461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy function for the on_activate ROS2 lifecycle function. This function is called by the main on_activate function and is made to adapted to the derived class. <br /></td></tr>
<tr class="separator:ae0e4c6f0ee0338d60bbdd805bfd83461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512b37f0fbb03d615fb9af881becf20b"><td class="memItemLeft" align="right" valign="top"><a id="a512b37f0fbb03d615fb9af881becf20b"></a>
rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a512b37f0fbb03d615fb9af881becf20b">on_deactivate</a> (const rclcpp_lifecycle::State &amp;) override</td></tr>
<tr class="memdesc:a512b37f0fbb03d615fb9af881becf20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition callback for state deactivating on_deactivate callback is being called when the lifecycle node enters the "deactivating" state. Depending on the return value of this function, the state machine either invokes a transition to the "inactive" state or stays in "active". TRANSITION_CALLBACK_SUCCESS transitions to "inactive" TRANSITION_CALLBACK_FAILURE transitions to "active" TRANSITION_CALLBACK_ERROR or any uncaught exceptions to "errorprocessing". <br /></td></tr>
<tr class="separator:a512b37f0fbb03d615fb9af881becf20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48b671104ecd9a4bf6fc30d3c506fa4"><td class="memItemLeft" align="right" valign="top"><a id="ae48b671104ecd9a4bf6fc30d3c506fa4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#ae48b671104ecd9a4bf6fc30d3c506fa4">on_deactivate</a> ()</td></tr>
<tr class="memdesc:ae48b671104ecd9a4bf6fc30d3c506fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy function for the on_deactivate ROS2 lifecycle function. This function is called by the main on_deactivate function and is made to adapted to the derived class. <br /></td></tr>
<tr class="separator:ae48b671104ecd9a4bf6fc30d3c506fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850da740ea227e830c79c458c73b4beb"><td class="memItemLeft" align="right" valign="top"><a id="a850da740ea227e830c79c458c73b4beb"></a>
rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a850da740ea227e830c79c458c73b4beb">on_cleanup</a> (const rclcpp_lifecycle::State &amp;) override</td></tr>
<tr class="memdesc:a850da740ea227e830c79c458c73b4beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition callback for state cleaningup on_cleanup callback is being called when the lifecycle node enters the "cleaningup" state. Depending on the return value of this function, the state machine either invokes a transition to the "unconfigured" state or stays in "inactive". TRANSITION_CALLBACK_SUCCESS transitions to "unconfigured" TRANSITION_CALLBACK_FAILURE transitions to "inactive" TRANSITION_CALLBACK_ERROR or any uncaught exceptions to "errorprocessing". <br /></td></tr>
<tr class="separator:a850da740ea227e830c79c458c73b4beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b318217741daed055ddf79b1c1d761"><td class="memItemLeft" align="right" valign="top"><a id="a48b318217741daed055ddf79b1c1d761"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a48b318217741daed055ddf79b1c1d761">on_cleanup</a> ()</td></tr>
<tr class="memdesc:a48b318217741daed055ddf79b1c1d761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy function for the on_cleanup ROS2 lifecycle function. This function is called by the main on_cleanup function and is made to adapted to the derived class. <br /></td></tr>
<tr class="separator:a48b318217741daed055ddf79b1c1d761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b4f0aa7ac5bf642c1d7e38b2db4e5b"><td class="memItemLeft" align="right" valign="top"><a id="a02b4f0aa7ac5bf642c1d7e38b2db4e5b"></a>
rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a02b4f0aa7ac5bf642c1d7e38b2db4e5b">on_shutdown</a> (const rclcpp_lifecycle::State &amp;state) override</td></tr>
<tr class="memdesc:a02b4f0aa7ac5bf642c1d7e38b2db4e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition callback for state shutting down on_shutdown callback is being called when the lifecycle node enters the "shuttingdown" state. Depending on the return value of this function, the state machine either invokes a transition to the "finalized" state or stays in its current state. TRANSITION_CALLBACK_SUCCESS transitions to "finalized" TRANSITION_CALLBACK_FAILURE transitions to current state TRANSITION_CALLBACK_ERROR or any uncaught exceptions to "errorprocessing". <br /></td></tr>
<tr class="separator:a02b4f0aa7ac5bf642c1d7e38b2db4e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce1c76cb46766ec9874646cf1ce520e"><td class="memItemLeft" align="right" valign="top"><a id="a4ce1c76cb46766ec9874646cf1ce520e"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a4ce1c76cb46766ec9874646cf1ce520e">on_shutdown</a> ()</td></tr>
<tr class="memdesc:a4ce1c76cb46766ec9874646cf1ce520e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy function for the on_shutdown ROS2 lifecycle function. This function is called by the main on_shutdown function and is made to adapted to the derived class. <br /></td></tr>
<tr class="separator:a4ce1c76cb46766ec9874646cf1ce520e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124e9ccd8487fd0c0b13d717586dd9a7"><td class="memItemLeft" align="right" valign="top"><a id="a124e9ccd8487fd0c0b13d717586dd9a7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a124e9ccd8487fd0c0b13d717586dd9a7">step</a> ()</td></tr>
<tr class="memdesc:a124e9ccd8487fd0c0b13d717586dd9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function computing one step of calculation. It is called periodically in the run function. <br /></td></tr>
<tr class="separator:a124e9ccd8487fd0c0b13d717586dd9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca69817a058fab19d3c6461ec4676b3"><td class="memItemLeft" align="right" valign="top"><a id="a4ca69817a058fab19d3c6461ec4676b3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a4ca69817a058fab19d3c6461ec4676b3">run</a> ()</td></tr>
<tr class="memdesc:a4ca69817a058fab19d3c6461ec4676b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main loop that will be executed in parallel of the rest. At each time step it calls the step function. <br /></td></tr>
<tr class="separator:a4ca69817a058fab19d3c6461ec4676b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac777a633e53c4539ff3227547ea0b0da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#ac777a633e53c4539ff3227547ea0b0da">run_periodic_call</a> (const std::function&lt; void(void)&gt; &amp;callback_function)</td></tr>
<tr class="memdesc:ac777a633e53c4539ff3227547ea0b0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to periodically call the given callback_function with guard protection and only when the node is active.  <a href="#ac777a633e53c4539ff3227547ea0b0da">More...</a><br /></td></tr>
<tr class="separator:ac777a633e53c4539ff3227547ea0b0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a182bde8032194d88e12e88a657d2b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a4a182bde8032194d88e12e88a657d2b1">add_periodic_call</a> (const std::function&lt; void(void)&gt; &amp;callback_function, const std::chrono::nanoseconds &amp;period)</td></tr>
<tr class="memdesc:a4a182bde8032194d88e12e88a657d2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add a periodic call to the function given in input.  <a href="#a4a182bde8032194d88e12e88a657d2b1">More...</a><br /></td></tr>
<tr class="separator:a4a182bde8032194d88e12e88a657d2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7722a0658045f35bcf4a5d66e027fc5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a7722a0658045f35bcf4a5d66e027fc5c">add_daemon</a> (const std::function&lt; void(void)&gt; &amp;callback_function, const std::chrono::nanoseconds &amp;period)</td></tr>
<tr class="memdesc:a7722a0658045f35bcf4a5d66e027fc5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to daemonize the callback function given in input.  <a href="#a7722a0658045f35bcf4a5d66e027fc5c">More...</a><br /></td></tr>
<tr class="separator:a7722a0658045f35bcf4a5d66e027fc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f5d3afec0c9c23799f889b44670149"><td class="memTemplParams" colspan="2"><a id="ad7f5d3afec0c9c23799f889b44670149"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad7f5d3afec0c9c23799f889b44670149"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_parameter_value</b> (const std::string &amp;parameter_name, const state_representation::CartesianState &amp;value)</td></tr>
<tr class="separator:ad7f5d3afec0c9c23799f889b44670149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8492f71fcb868bcf4e6d93d733dda13c"><td class="memTemplParams" colspan="2"><a id="a8492f71fcb868bcf4e6d93d733dda13c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a8492f71fcb868bcf4e6d93d733dda13c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_parameter_value</b> (const std::string &amp;parameter_name, const state_representation::CartesianPose &amp;value)</td></tr>
<tr class="separator:a8492f71fcb868bcf4e6d93d733dda13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34cf037caec859f14cbd37ffbc05240"><td class="memTemplParams" colspan="2"><a id="af34cf037caec859f14cbd37ffbc05240"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af34cf037caec859f14cbd37ffbc05240"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_parameter_value</b> (const std::string &amp;parameter_name, const state_representation::JointState &amp;value)</td></tr>
<tr class="separator:af34cf037caec859f14cbd37ffbc05240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad878cf753cba0abd2146b48630fe567e"><td class="memTemplParams" colspan="2"><a id="ad878cf753cba0abd2146b48630fe567e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad878cf753cba0abd2146b48630fe567e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_parameter_value</b> (const std::string &amp;parameter_name, const state_representation::JointPositions &amp;value)</td></tr>
<tr class="separator:ad878cf753cba0abd2146b48630fe567e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f3144aa6b7ed685126f64852a8f8ca"><td class="memTemplParams" colspan="2"><a id="ae3f3144aa6b7ed685126f64852a8f8ca"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae3f3144aa6b7ed685126f64852a8f8ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_parameter_value</b> (const std::string &amp;parameter_name, const state_representation::Ellipsoid &amp;value)</td></tr>
<tr class="separator:ae3f3144aa6b7ed685126f64852a8f8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe04b7727d8d9fc6e71d4f62475bd3e"><td class="memTemplParams" colspan="2"><a id="a5fe04b7727d8d9fc6e71d4f62475bd3e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5fe04b7727d8d9fc6e71d4f62475bd3e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_parameter_value</b> (const std::string &amp;parameter_name, const Eigen::MatrixXd &amp;value)</td></tr>
<tr class="separator:a5fe04b7727d8d9fc6e71d4f62475bd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9c2dc9803620fff2ed5995bbabd5fb32"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, std::pair&lt; std::shared_ptr&lt; <a class="el" href="classmodulo_1_1core_1_1communication_1_1_communication_handler.html">communication::CommunicationHandler</a> &gt;, bool &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a9c2dc9803620fff2ed5995bbabd5fb32">get_handlers</a> () const</td></tr>
<tr class="memdesc:a9c2dc9803620fff2ed5995bbabd5fb32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter of the handlers attribute.  <a href="#a9c2dc9803620fff2ed5995bbabd5fb32">More...</a><br /></td></tr>
<tr class="separator:a9c2dc9803620fff2ed5995bbabd5fb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9605a6d6f3cd7e25a2cd7c1fc055f598"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; state_representation::ParameterInterface &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodulo_1_1core_1_1_cell.html#a9605a6d6f3cd7e25a2cd7c1fc055f598">get_parameter_pointer</a> (const std::string &amp;parameter_name) const</td></tr>
<tr class="memdesc:a9605a6d6f3cd7e25a2cd7c1fc055f598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the desired parameter.  <a href="#a9605a6d6f3cd7e25a2cd7c1fc055f598">More...</a><br /></td></tr>
<tr class="separator:a9605a6d6f3cd7e25a2cd7c1fc055f598"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract class to define a <a class="el" href="classmodulo_1_1core_1_1_cell.html" title="Abstract class to define a Cell A Cell is the base class of the whole architecture. It handles all the basic ROS communications such as definitions of subscriptions, publishers and service calls. It can then be derived into a MotionGenerator, a Controller, a Sensor, or a RobotInterface. It is derived from a lifecycle node which allows to use ROS2 state machine functionalities for nodes. ">Cell</a> A <a class="el" href="classmodulo_1_1core_1_1_cell.html" title="Abstract class to define a Cell A Cell is the base class of the whole architecture. It handles all the basic ROS communications such as definitions of subscriptions, publishers and service calls. It can then be derived into a MotionGenerator, a Controller, a Sensor, or a RobotInterface. It is derived from a lifecycle node which allows to use ROS2 state machine functionalities for nodes. ">Cell</a> is the base class of the whole architecture. It handles all the basic ROS communications such as definitions of subscriptions, publishers and service calls. It can then be derived into a MotionGenerator, a Controller, a Sensor, or a RobotInterface. It is derived from a lifecycle node which allows to use ROS2 state machine functionalities for nodes. </p>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00039">39</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6f54f87fdeab9b58624f41a8c36c325c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f54f87fdeab9b58624f41a8c36c325c">&#9670;&nbsp;</a></span>Cell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DurationT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">modulo::core::Cell::Cell </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>node_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; int64_t, DurationT &gt; &amp;&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>intra_process_comms</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmodulo_1_1core_1_1_cell.html" title="Abstract class to define a Cell A Cell is the base class of the whole architecture. It handles all the basic ROS communications such as definitions of subscriptions, publishers and service calls. It can then be derived into a MotionGenerator, a Controller, a Sensor, or a RobotInterface. It is derived from a lifecycle node which allows to use ROS2 state machine functionalities for nodes. ">Cell</a> constructor with arguments needed from ROS2 node. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DurationT</td><td>template value for accepting any type of std::chrono duration values </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_name</td><td>name of the ROS node </td></tr>
    <tr><td class="paramname">period</td><td>the period of each step function call </td></tr>
    <tr><td class="paramname">intra_process_comms</td><td>ROS2 parameter to declare if nodes share the same memory for instant process communication </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00557">557</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="ab4de79f0ad4ecfab5dc8622b25435fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4de79f0ad4ecfab5dc8622b25435fc5">&#9670;&nbsp;</a></span>Cell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">modulo::core::Cell::Cell </td>
          <td>(</td>
          <td class="paramtype">const rclcpp::NodeOptions &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmodulo_1_1core_1_1_cell.html" title="Abstract class to define a Cell A Cell is the base class of the whole architecture. It handles all the basic ROS communications such as definitions of subscriptions, publishers and service calls. It can then be derived into a MotionGenerator, a Controller, a Sensor, or a RobotInterface. It is derived from a lifecycle node which allows to use ROS2 state machine functionalities for nodes. ">Cell</a> construction from ROS2 NodeOptions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>NodeOptions containing a node name in the remapping arguments list and a "period" parameter with a value in seconds in the parameter override list </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8cpp_source.html#l00012">12</a> of file <a class="el" href="_cell_8cpp_source.html">Cell.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a38f0168a5774facb8660e8527d4827a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f0168a5774facb8660e8527d4827a9">&#9670;&nbsp;</a></span>add_client()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename srvT , typename DurationT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::add_client </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; int64_t, DurationT &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template function to add a generic client to the map of handlers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">srvT</td><td>tamplate value to accept any type of ROS2 services </td></tr>
    <tr><td class="paramname">DurationT</td><td>template value for accepting any type of std::chrono duration values </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>unique name of the communication topic between the client and the server </td></tr>
    <tr><td class="paramname">timeout</td><td>period before considering the server is not responding </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00736">736</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="a7722a0658045f35bcf4a5d66e027fc5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7722a0658045f35bcf4a5d66e027fc5c">&#9670;&nbsp;</a></span>add_daemon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::add_daemon </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::nanoseconds &amp;&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to daemonize the callback function given in input. </p>
<p>This function is similar to the add_periodic_call one with the difference that a daemon is always active, including when the node is not configured. The desired design is, therefore, that it should be called only in the constructor to avoid potential duplicates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback_function</td><td>the function to call </td></tr>
    <tr><td class="paramname">period</td><td>the period between two calls </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8cpp_source.html#l00462">462</a> of file <a class="el" href="_cell_8cpp_source.html">Cell.cpp</a>.</p>

</div>
</div>
<a id="a7aea311b40f849bde13cbd343fbc35be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aea311b40f849bde13cbd343fbc35be">&#9670;&nbsp;</a></span>add_parameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template void modulo::core::Cell::add_parameter&lt; bool &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; state_representation::Parameter&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a parameter to be updated by the parameter server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter</td><td>The parameter using the state_representation of a parameter </td></tr>
    <tr><td class="paramname">prefix</td><td>a string for prefixing the parameter name </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8cpp_source.html#l00042">42</a> of file <a class="el" href="_cell_8cpp_source.html">Cell.cpp</a>.</p>

</div>
</div>
<a id="a51fd1167640d8de301c9f69323a493c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51fd1167640d8de301c9f69323a493c4">&#9670;&nbsp;</a></span>add_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::add_parameters </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; std::shared_ptr&lt; state_representation::ParameterInterface &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add multiple parameters to be updated by the parameter server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>the list of parameters </td></tr>
    <tr><td class="paramname">prefix</td><td>a string for prefixing the parameter name </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8cpp_source.html#l00112">112</a> of file <a class="el" href="_cell_8cpp_source.html">Cell.cpp</a>.</p>

</div>
</div>
<a id="a4a182bde8032194d88e12e88a657d2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a182bde8032194d88e12e88a657d2b1">&#9670;&nbsp;</a></span>add_periodic_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::add_periodic_call </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::nanoseconds &amp;&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to add a periodic call to the function given in input. </p>
<p>This function is similar to the add_deamon one with the difference that the callback_function is only called when the node is active. The desired design is, therefore, that it should only be called in the on_configure function, as periodic_call will be cleaned when on_cleanup is called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback_function</td><td>the function to call </td></tr>
    <tr><td class="paramname">period</td><td>the period between two calls </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8cpp_source.html#l00458">458</a> of file <a class="el" href="_cell_8cpp_source.html">Cell.cpp</a>.</p>

</div>
</div>
<a id="a9db583f79249081e49dcd5867801a1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db583f79249081e49dcd5867801a1da">&#9670;&nbsp;</a></span>add_publisher() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MsgT , class RecT , typename DurationT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::add_publisher </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; RecT &gt; &amp;&#160;</td>
          <td class="paramname"><em>recipient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; int64_t, DurationT &gt; &amp;&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>always_active</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_size</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template function to add a generic publisher to the map of handlers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MsgT</td><td>template value for accepting any type of ROS2 messages </td></tr>
    <tr><td class="paramname">RecT</td><td>template value for accepting any type of recipient </td></tr>
    <tr><td class="paramname">DurationT</td><td>template value for accepting any type of std::chrono duration values </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>unique name of the publish channel that is used as key to the map </td></tr>
    <tr><td class="paramname">recipient</td><td>the state that contain the data to be published </td></tr>
    <tr><td class="paramname">period</td><td>the period to wait between two publishing </td></tr>
    <tr><td class="paramname">always_active</td><td>if true, always publish even if the node is not configured </td></tr>
    <tr><td class="paramname">queue_size</td><td>publisher parameters indicating the maximum size of the buffer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00596">596</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="ad29cfa3a50c8e5dff204d8d3a77bbfdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29cfa3a50c8e5dff204d8d3a77bbfdd">&#9670;&nbsp;</a></span>add_publisher() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MsgT , class RecT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::add_publisher </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; RecT &gt; &amp;&#160;</td>
          <td class="paramname"><em>recipient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>always_active</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_size</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template function to add a generic publisher to the map of handlers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MsgT</td><td>template value for accepting any type of ROS2 messages </td></tr>
    <tr><td class="paramname">RecT</td><td>template value for accepting any type of recipient </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>unique name of the publish channel that is used as key to the map </td></tr>
    <tr><td class="paramname">recipient</td><td>the state that contain the data to be published </td></tr>
    <tr><td class="paramname">always_active</td><td>if true, always publish even if the node is not configured </td></tr>
    <tr><td class="paramname">queue_size</td><td>publisher parameters indicating the maximum size of the buffer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00612">612</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="a5e7606dc7a4d36f1f8bb8e4011087a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e7606dc7a4d36f1f8bb8e4011087a7d">&#9670;&nbsp;</a></span>add_state_publisher() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RecT , typename DurationT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::add_state_publisher </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; RecT &gt; &amp;&#160;</td>
          <td class="paramname"><em>recipient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; int64_t, DurationT &gt; &amp;&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>always_active</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_size</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template function to add a specific state publisher that makes use of protobuf encodings to the map of handlers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RecT</td><td>template value for accepting any State type recipient </td></tr>
    <tr><td class="paramname">DurationT</td><td>template value for accepting any type of std::chrono duration values </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>unique name of the publish channel that is used as key to the map </td></tr>
    <tr><td class="paramname">recipient</td><td>the state that contain the data to be published </td></tr>
    <tr><td class="paramname">period</td><td>the period to wait between two publishing </td></tr>
    <tr><td class="paramname">always_active</td><td>if true, always publish even if the node is not configured </td></tr>
    <tr><td class="paramname">queue_size</td><td>publisher parameters indicating the maximum size of the buffer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00620">620</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="adbb76634b4d55866ee751127082906c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb76634b4d55866ee751127082906c9">&#9670;&nbsp;</a></span>add_state_publisher() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RecT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::add_state_publisher </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; RecT &gt; &amp;&#160;</td>
          <td class="paramname"><em>recipient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>always_active</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_size</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template function to add a specific state publisher that makes use of protobuf encodings to the map of handlers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RecT</td><td>template value for accepting any State type recipient </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>unique name of the publish channel that is used as key to the map </td></tr>
    <tr><td class="paramname">recipient</td><td>the state that contain the data to be published </td></tr>
    <tr><td class="paramname">always_active</td><td>if true, always publish even if the node is not configured </td></tr>
    <tr><td class="paramname">queue_size</td><td>publisher parameters indicating the maximum size of the buffer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00629">629</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="ad95ae271520a43ff6cebfee4dcc3ca8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95ae271520a43ff6cebfee4dcc3ca8c">&#9670;&nbsp;</a></span>add_state_subscription() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RecT , typename DurationT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::add_state_subscription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; RecT &gt; &amp;&#160;</td>
          <td class="paramname"><em>recipient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; int64_t, DurationT &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>always_active</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_size</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template function to add a specific state subscription that makes use of protobuf decoding to the map of handlers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RecT</td><td>template value for accepting any State type recipient </td></tr>
    <tr><td class="paramname">DurationT</td><td>template value for accepting any type of std::chrono duration values </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>unique name of the subscription channel that is used as key to the map </td></tr>
    <tr><td class="paramname">recipient</td><td>the state that will contain the received data </td></tr>
    <tr><td class="paramname">timeout</td><td>the period after wich to consider that the subscriber has timeout </td></tr>
    <tr><td class="paramname">always_active</td><td>if true, always receive messages from the topic even if the node is not configured </td></tr>
    <tr><td class="paramname">queue_size</td><td>subscriber parameters indicating the maximum size of the buffer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00660">660</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="a20fee86d69a6a08d16f3e3e81b526522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fee86d69a6a08d16f3e3e81b526522">&#9670;&nbsp;</a></span>add_state_subscription() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RecT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::add_state_subscription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; RecT &gt; &amp;&#160;</td>
          <td class="paramname"><em>recipient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>always_active</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nb_period_to_timeout</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_size</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template function to add a specific state subscription that makes use of protobuf decoding to the map of handlers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RecT</td><td>template value for accepting any State type recipient </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>unique name of the subscription channel that is used as key to the map </td></tr>
    <tr><td class="paramname">recipient</td><td>the state that will contain the received data </td></tr>
    <tr><td class="paramname">always_active</td><td>if true, always receive messages from the topic even if the node is not configured </td></tr>
    <tr><td class="paramname">nb_period_to_timeout</td><td>the number of period before considering that the subscription has timeout </td></tr>
    <tr><td class="paramname">queue_size</td><td>subscriber parameters indicating the maximum size of the buffer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00669">669</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="a7389de153da8a35b50ee7c089a806b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7389de153da8a35b50ee7c089a806b4a">&#9670;&nbsp;</a></span>add_subscription() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MsgT , class RecT , typename DurationT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::add_subscription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; RecT &gt; &amp;&#160;</td>
          <td class="paramname"><em>recipient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; int64_t, DurationT &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>always_active</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_size</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template function to add a generic subscription to the map of handlers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MsgT</td><td>template value for accepting any type of ROS2 messages </td></tr>
    <tr><td class="paramname">RecT</td><td>template value for accepting any type of recipient </td></tr>
    <tr><td class="paramname">DurationT</td><td>template value for accepting any type of std::chrono duration values </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>unique name of the subscription channel that is used as key to the map </td></tr>
    <tr><td class="paramname">recipient</td><td>the state that will contain the received data </td></tr>
    <tr><td class="paramname">timeout</td><td>the period after wich to consider that the subscriber has timeout </td></tr>
    <tr><td class="paramname">always_active</td><td>if true, always receive messages from the topic even if the node is not configured </td></tr>
    <tr><td class="paramname">queue_size</td><td>subscriber parameters indicating the maximum size of the buffer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00637">637</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="ab3f36681d56926a2e6d091953f337eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f36681d56926a2e6d091953f337eb7">&#9670;&nbsp;</a></span>add_subscription() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MsgT , class RecT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::add_subscription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; RecT &gt; &amp;&#160;</td>
          <td class="paramname"><em>recipient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>always_active</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nb_period_to_timeout</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_size</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template function to add a generic subscription to the map of handlers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>unique name of the subscription channel that is used as key to the map </td></tr>
    <tr><td class="paramname">recipient</td><td>the state that will contain the received data </td></tr>
    <tr><td class="paramname">always_active</td><td>if true, always receive messages from the topic even if the node is not configured </td></tr>
    <tr><td class="paramname">nb_period_to_timeout</td><td>the number of period before considering that the subscription has timeout </td></tr>
    <tr><td class="paramname">queue_size</td><td>subscriber parameters indicating the maximum size of the buffer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00651">651</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="ae4927517bf0bc8b94d6cb5decefb823b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4927517bf0bc8b94d6cb5decefb823b">&#9670;&nbsp;</a></span>add_transform_broadcaster() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DurationT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::add_transform_broadcaster </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; state_representation::CartesianState &gt; &amp;&#160;</td>
          <td class="paramname"><em>recipient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; int64_t, DurationT &gt; &amp;&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>always_active</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_size</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to add a generic transform broadcaster to the map of handlers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recipient</td><td>the state that contain the data to be published </td></tr>
    <tr><td class="paramname">period</td><td>the period to wait between two publishing </td></tr>
    <tr><td class="paramname">always_active</td><td>if true, always publish the transform even if the node is not configured </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00691">691</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="a93af246ceb62834fba40ae7e196a4f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93af246ceb62834fba40ae7e196a4f6f">&#9670;&nbsp;</a></span>add_transform_broadcaster() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DurationT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::add_transform_broadcaster </td>
          <td>(</td>
          <td class="paramtype">const state_representation::CartesianPose &amp;&#160;</td>
          <td class="paramname"><em>recipient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; int64_t, DurationT &gt; &amp;&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>always_active</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_size</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to add a generic transform broadcaster to the map of handlers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recipient</td><td>the state that contain the data to be published </td></tr>
    <tr><td class="paramname">period</td><td>the period to wait between two publishing </td></tr>
    <tr><td class="paramname">always_active</td><td>if true, always publish the transform even if the node is not configured </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00705">705</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="a33d6de7a100ec206d253fb5c464568bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d6de7a100ec206d253fb5c464568bb">&#9670;&nbsp;</a></span>add_transform_broadcaster() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DurationT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::add_transform_broadcaster </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; state_representation::ParameterInterface &gt; &amp;&#160;</td>
          <td class="paramname"><em>recipient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; int64_t, DurationT &gt; &amp;&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>always_active</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_size</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to add a generic transform broadcaster to the map of handlers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recipient</td><td>the state that contain the data to be published </td></tr>
    <tr><td class="paramname">period</td><td>the period to wait between two publishing </td></tr>
    <tr><td class="paramname">always_active</td><td>if true, always publish the transform even if the node is not configured </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00713">713</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="a1715e6ba3c3976921f4e6d92284d7369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1715e6ba3c3976921f4e6d92284d7369">&#9670;&nbsp;</a></span>add_transform_broadcaster() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::add_transform_broadcaster </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; state_representation::CartesianState &gt; &amp;&#160;</td>
          <td class="paramname"><em>recipient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>always_active</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_size</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to add a generic transform broadcaster to the map of handlers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recipient</td><td>the state that contain the data to be published </td></tr>
    <tr><td class="paramname">always_active</td><td>if true, always publish the transform even if the node is not configured </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8cpp_source.html#l00309">309</a> of file <a class="el" href="_cell_8cpp_source.html">Cell.cpp</a>.</p>

</div>
</div>
<a id="ac069bec4807a256f2473b41d5625fc14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac069bec4807a256f2473b41d5625fc14">&#9670;&nbsp;</a></span>add_transform_broadcaster() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::add_transform_broadcaster </td>
          <td>(</td>
          <td class="paramtype">const state_representation::CartesianPose &amp;&#160;</td>
          <td class="paramname"><em>recipient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>always_active</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_size</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to add a generic transform broadcaster to the map of handlers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recipient</td><td>the state that contain the data to be published </td></tr>
    <tr><td class="paramname">always_active</td><td>if true, always publish the transform even if the node is not configured </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8cpp_source.html#l00315">315</a> of file <a class="el" href="_cell_8cpp_source.html">Cell.cpp</a>.</p>

</div>
</div>
<a id="a25a1fcc562c8ac09b6bad98e080915e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a1fcc562c8ac09b6bad98e080915e2">&#9670;&nbsp;</a></span>add_transform_broadcaster() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::add_transform_broadcaster </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; state_representation::ParameterInterface &gt; &amp;&#160;</td>
          <td class="paramname"><em>recipient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>always_active</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queue_size</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to add a generic transform broadcaster to the map of handlers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recipient</td><td>the state that contain the data to be published </td></tr>
    <tr><td class="paramname">always_active</td><td>if true, always publish the transform even if the node is not configured </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8cpp_source.html#l00321">321</a> of file <a class="el" href="_cell_8cpp_source.html">Cell.cpp</a>.</p>

</div>
</div>
<a id="a9c2dc9803620fff2ed5995bbabd5fb32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2dc9803620fff2ed5995bbabd5fb32">&#9670;&nbsp;</a></span>get_handlers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::string, std::pair&lt; std::shared_ptr&lt; <a class="el" href="classmodulo_1_1core_1_1communication_1_1_communication_handler.html">communication::CommunicationHandler</a> &gt;, bool &gt; &gt; &amp; modulo::core::Cell::get_handlers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter of the handlers attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the handlers attribute </dd></dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00566">566</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="a9605a6d6f3cd7e25a2cd7c1fc055f598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9605a6d6f3cd7e25a2cd7c1fc055f598">&#9670;&nbsp;</a></span>get_parameter_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt; state_representation::ParameterInterface &gt; modulo::core::Cell::get_parameter_pointer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameter_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the pointer to the desired parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter_name</td><td>the name of the desired parameter </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00586">586</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="af13211781282916bdcd836289088f729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13211781282916bdcd836289088f729">&#9670;&nbsp;</a></span>get_period()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::chrono::nanoseconds &amp; modulo::core::Cell::get_period </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter of the period attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the period attribute </dd></dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00582">582</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="ace47d79114cbba0fd4d84088df49a1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace47d79114cbba0fd4d84088df49a1ea">&#9670;&nbsp;</a></span>is_active()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool modulo::core::Cell::is_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter of the active boolean attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>true if active </dd></dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00574">574</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="a3474ece0416029d4f404af1b2910c1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3474ece0416029d4f404af1b2910c1d6">&#9670;&nbsp;</a></span>is_configured()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool modulo::core::Cell::is_configured </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter of the configured boolean attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>true if configured </dd></dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00570">570</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="aca6cd4b8d5d95ee9df36963902f1dbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6cd4b8d5d95ee9df36963902f1dbc1">&#9670;&nbsp;</a></span>is_shutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool modulo::core::Cell::is_shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter of the shutdown boolean attribute. </p>
<dl class="section return"><dt>Returns</dt><dd>true if shutdown </dd></dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00578">578</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="a11d57545c240e5f2fec3376dbbb11799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d57545c240e5f2fec3376dbbb11799">&#9670;&nbsp;</a></span>lookup_transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const state_representation::CartesianPose modulo::core::Cell::lookup_transform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frame_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reference_frame</em> = <code>&quot;world&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get a transform from the generic transform listener. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame_name</td><td>name of the frame to look for </td></tr>
    <tr><td class="paramname">the</td><td>frame in wich to express the transform </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the CartesianPose representing the transformation </dd></dl>

<p class="definition">Definition at line <a class="el" href="_cell_8cpp_source.html#l00334">334</a> of file <a class="el" href="_cell_8cpp_source.html">Cell.cpp</a>.</p>

</div>
</div>
<a id="ac777a633e53c4539ff3227547ea0b0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac777a633e53c4539ff3227547ea0b0da">&#9670;&nbsp;</a></span>run_periodic_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::run_periodic_call </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback_function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to periodically call the given callback_function with guard protection and only when the node is active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback_function</td><td>the function to call </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8cpp_source.html#l00452">452</a> of file <a class="el" href="_cell_8cpp_source.html">Cell.cpp</a>.</p>

</div>
</div>
<a id="a2b911abe115972016e13913d6349d84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b911abe115972016e13913d6349d84e">&#9670;&nbsp;</a></span>send_blocking_request()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename srvT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; typename srvT::Response &gt; modulo::core::Cell::send_blocking_request </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; typename srvT::Request &gt; &amp;&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a request to the server and wait for its response. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel of communication </td></tr>
    <tr><td class="paramname">request</td><td>the request to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the response from the server </dd></dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00743">743</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="a8be9304077256da63314cb715cf66a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be9304077256da63314cb715cf66a1e">&#9670;&nbsp;</a></span>send_request()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename srvT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_future&lt; std::shared_ptr&lt; typename srvT::Response &gt; &gt; modulo::core::Cell::send_request </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; typename srvT::Request &gt; &amp;&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a request to the server without waiting for its response. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel of communication </td></tr>
    <tr><td class="paramname">request</td><td>the request to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the response from the server </dd></dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00748">748</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="a3f26e56b46a72d381cd78aff188b7bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f26e56b46a72d381cd78aff188b7bcb">&#9670;&nbsp;</a></span>send_transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::send_transform </td>
          <td>(</td>
          <td class="paramtype">const state_representation::CartesianState &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to send a transform using the generic transform broadcaster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>the transformation to send </td></tr>
    <tr><td class="paramname">name</td><td>the new name to give to the transform. If empty it will use the name provided in transform </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8cpp_source.html#l00327">327</a> of file <a class="el" href="_cell_8cpp_source.html">Cell.cpp</a>.</p>

</div>
</div>
<a id="aee6e888001df99c8201dc728709d05ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6e888001df99c8201dc728709d05ae">&#9670;&nbsp;</a></span>set_parameter_value() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::set_parameter_value </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameter_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a declared parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter</td><td>the new value of the parameter </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8cpp_source.html#l00185">185</a> of file <a class="el" href="_cell_8cpp_source.html">Cell.cpp</a>.</p>

</div>
</div>
<a id="a56c491b299de1d33d8f32389cdfd5c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c491b299de1d33d8f32389cdfd5c9b">&#9670;&nbsp;</a></span>set_parameter_value() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::set_parameter_value </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; state_representation::Parameter&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>parameter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a declared parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter</td><td>the new value of the parameter </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8hpp_source.html#l00591">591</a> of file <a class="el" href="_cell_8hpp_source.html">Cell.hpp</a>.</p>

</div>
</div>
<a id="a948e1b5a2a7fa1a36d4f6cdf6e7eb7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948e1b5a2a7fa1a36d4f6cdf6e7eb7a1">&#9670;&nbsp;</a></span>set_parameter_value() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void modulo::core::Cell::set_parameter_value </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; state_representation::ParameterInterface &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a declared parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter</td><td>the new value of the parameter </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_cell_8cpp_source.html#l00239">239</a> of file <a class="el" href="_cell_8cpp_source.html">Cell.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/enricoeberhard/Documents/EPFL/Dev/modulo/source/modulo_core/include/modulo_core/<a class="el" href="_cell_8hpp_source.html">Cell.hpp</a></li>
<li>/Users/enricoeberhard/Documents/EPFL/Dev/modulo/source/modulo_core/src/<a class="el" href="_cell_8cpp_source.html">Cell.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
