<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Modulo: Modulo Core</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Modulo<span id="projectnumber">&#160;2.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Modulo Core </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >Modulo Core is an interface package to support the interoperability of the <a href="https://www.ros.org">Robot Operating System (ROS)</a> with <a href="https://github.com/epfl-lasa/control-libraries">EPFL LASA control libraries</a> by providing communication and translation utilities.</p>
<p >This package is specifically designed for ROS2 and was developed on Galactic Geochelone.</p>
<h1>Communication</h1>
<p >In ROS, applications communicate through publishers and subscribers. Communication is handled in a particular format (a ROS message), which includes a serialized representation of the data as well as a message header. For example, data of type <code>bool</code> maps to the standard message <code>std_msgs::msg::Bool</code>.</p>
<p >If application A wishes to send data to application B, a publisher of A and a subscriber of B must be configured to the same ROS message type. The data is written into the message format and published by A. B receives the message and can read the data back out.</p>
<h2>MessagePair</h2>
<p >The communication module simplifies the process of sending and receiving data by binding data types to their respective message types in a <code>MessagePair</code>. <code>MessagePair</code> objects are templated containers holding a pointer to the data. With a <code>MessagePair</code> instance, it is possible to set and get the data or read and write the corresponding message with simple access methods. The conversion between the data and the message when reading or writing is handled by the translators module.</p>
<h2>MessageType</h2>
<p >The supported groupings of data types and message types is defined by the <code>MessageType</code> enumeration. See the <a href="./include/modulo_core/communication/MessageType.h"><code>MessageType</code> header file</a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">MessageType   </th><th class="markdownTableHeadNone">C++ data type   </th><th class="markdownTableHeadNone">ROS message type    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>BOOL</code>   </td><td class="markdownTableBodyNone"><code>bool</code>   </td><td class="markdownTableBodyNone"><code>std_msgs::msgs::Bool</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>INT32</code>   </td><td class="markdownTableBodyNone"><code>int</code>   </td><td class="markdownTableBodyNone"><code>std_msgs::msgs::Int32</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>FLOAT64</code>   </td><td class="markdownTableBodyNone"><code>double</code>   </td><td class="markdownTableBodyNone"><code>std_msgs::msgs::FLOAT64</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>FLOAT64_MUlTI_ARRAY</code>   </td><td class="markdownTableBodyNone"><code>std::vector&lt;double&gt;</code>   </td><td class="markdownTableBodyNone"><code>std_msgs::msgs::FLOAT64MultiArray</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>STRING</code>   </td><td class="markdownTableBodyNone"><code>std::string</code>   </td><td class="markdownTableBodyNone"><code>std_msgs::msgs::String</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ENCODED_STATE</code>   </td><td class="markdownTableBodyNone"><code>state_representation::State</code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="namespacemodulo__core.html#aa89356b8fb7ab13ff2514931d3b05fdc" title="Define the EncodedState as UInt8MultiArray message type.">modulo_core::EncodedState</a></code>   </td></tr>
</table>
<h2>Encoded State</h2>
<p >The <code>ENCODED_STATE</code> type supports all classes in the family of <code>state_representation::State</code>. It uses the <code>clproto</code> serialization library from control_libraries to encode <code>State</code> type messages to and from a binary format. The message type <code><a class="el" href="namespacemodulo__core.html#aa89356b8fb7ab13ff2514931d3b05fdc" title="Define the EncodedState as UInt8MultiArray message type.">modulo_core::EncodedState</a></code> is equivalent to the ROS <code>std_msgs::msg::UInt8MultiArray</code>.</p>
<p >The helper function <code>state_representation::make_shared_state(state_instance)</code> can be used to inject any <code>State</code>-derived instance in a <code>std::shared_ptr&lt;state_representation::State&gt;</code> pointer for the MessagePair.</p>
<h2>MessagePairInterface</h2>
<p >As <code>MessagePair</code> instances need to be templated by the data type and message type, they can be somewhat verbose to manage directly. For example, storing multiple <code>MessagePair</code> instances in a container or passing them as function arguments would require additional templating.</p>
<p >The <code>MessagePairInterface</code> is the non-templated base class of the <code>MessagePair</code>. By injecting a reference to a <code>MessagePair</code> into a <code>MessagePairInterface</code> pointer, it is possible to manage any <code>MessagePair</code> in a generic, type-agnostic way.</p>
<p >The <code>MessageType</code> property of the <code>MessagePairInterface</code> allows introspection of the contained <code>MessagePair</code> type, and, through dynamic down-casting, both the <code>MessagePair</code> instance and contained data may be retrieved.</p>
<h2>Publisher and Subscription Interfaces</h2>
<p >To send and receive ROS messages, applications must create publishers and subscribers templated to the corresponding ROS message type. A ROS publisher provides a <code>publish</code> method which takes a ROS message as the argument. A ROS subscription forwards an incoming ROS message to a callback function.</p>
<p >By virtue of the <code>MessagePair</code> design pattern, the underlying ROS message types can be fully encapsulated and hidden from the user, allowing applications to simply publish and subscribe to supported data types.</p>
<h3>Publisher</h3>
<p >The <code>PublisherHandler</code> is a templated wrapper for a ROS publisher that additionally holds a <code>MessagePair</code> reference. This allows the user to invoke a <code>publish()</code> method without having to pass a ROS message as an argument. Instead, the data referenced by the MessagePair is automatically translated into a ROS message and published.</p>
<p >The <code>PublisherHandler</code> supports multiple publisher types, namely for standard or lifecycle publishers.</p>
<p >The intended pattern for the developer is shown below. There are a few more setup steps compared to creating a standard ROS publisher. However, once the publisher interface has been established, modifying and publishing the referenced data is greatly simplified.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">using namespace modulo_core::communication;</div>
<div class="line">typedef std_msgs::msg::FLOAT64 MsgT;</div>
<div class="line">auto node = std::make_shared&lt;rclcpp::Node&gt;(&quot;example&quot;);</div>
<div class="line"> </div>
<div class="line">// hold a pointer reference to some data that should be published</div>
<div class="line">auto data = std::make_shared&lt;double&gt;(1.0);</div>
<div class="line"> </div>
<div class="line">// make a MessagePair to bind the data pointer to the corresponding ROS message</div>
<div class="line">auto message_pair = std::make_shared&lt;MessagePair&lt;MsgT, double&gt;&gt;(data, rclcpp::Clock());</div>
<div class="line"> </div>
<div class="line">// create the ROS publisher</div>
<div class="line">auto publisher = node-&gt;create_publisher&lt;MsgT&gt;(&quot;topic&quot;, 10);</div>
<div class="line"> </div>
<div class="line">// create the PublisherHandler from the ROS publisher</div>
<div class="line">auto publisher_handler =</div>
<div class="line">  std::make_shared&lt;PublisherHandler&lt;rclcpp::Publisher&lt;MsgT&gt;, MsgT&gt;&gt;(PublisherType::PUBLISHER, publisher);</div>
<div class="line"> </div>
<div class="line">// encapsulate the PublisherHandler in a PublisherInterface</div>
<div class="line">std::shared_ptr&lt;PublisherInterface&gt; publisher_interface(publisher_handler);</div>
<div class="line"> </div>
<div class="line">// pass the MessagePair to the PublisherInterface </div>
<div class="line">publisher_interface-&gt;set_message_pair(message_pair);</div>
<div class="line"> </div>
<div class="line">// now, the data can be published, with automatic translation of the data value into a ROS message</div>
<div class="line">publisher_interface-&gt;publish();</div>
<div class="line"> </div>
<div class="line">// because the PublisherInterface holds a reference to the MessagePair, which in turn references the original data,</div>
<div class="line">// any changes to the data value will be observed when publishing. </div>
<div class="line">*data = 2.0;</div>
<div class="line">publisher_interface-&gt;publish();</div>
</div><!-- fragment --><h3>Subscription</h3>
<p >The <code>SubscriptionHandler</code> is a templated wrapper for a ROS subscription that additionally holds a <code>MessagePair</code> reference. When the subscription receives a message, the <code>SubscriptionHandler</code> callback automatically translates the ROS message and updates the value of the data referenced by the <code>MessagePair</code>.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">using namespace modulo_core::communication;</div>
<div class="line">typedef std_msgs::msg::FLOAT64 MsgT;</div>
<div class="line">auto node = std::make_shared&lt;rclcpp::Node&gt;(&quot;example&quot;);</div>
<div class="line"> </div>
<div class="line">// hold a pointer reference to some data that should be published</div>
<div class="line">auto data = std::make_shared&lt;double&gt;(1.0);</div>
<div class="line"> </div>
<div class="line">// make a MessagePair to bind the data pointer to the corresponding ROS message</div>
<div class="line">auto message_pair = std::make_shared&lt;MessagePair&lt;MsgT, double&gt;&gt;(data, rclcpp::Clock());</div>
<div class="line"> </div>
<div class="line">// create the SubscriptionHandler</div>
<div class="line">auto subscription_handler = std::make_shared&lt;SubscriptionHandler&lt;modulo_core::EncodedState&gt;&gt;(message_pair);</div>
<div class="line"> </div>
<div class="line">// create the ROS subscription and associate the SubscriptionHandler callback</div>
<div class="line">auto subscription = node-&gt;create_subscription&lt;modulo_core::EncodedState&gt;(</div>
<div class="line">    &quot;topic&quot;, 10, subscription_handler-&gt;get_callback());</div>
<div class="line"> </div>
<div class="line">// encapsulate the SubscriptionHandler in a SubscriptionInterface</div>
<div class="line">auto subscription_interface = subscription_handler-&gt;create_subscription_interface(subscription);</div>
<div class="line"> </div>
<div class="line">// because the SubscriptionInterface holds a reference to the MessagePair, which in turn references the original data,</div>
<div class="line">// any received ROS message will be translated to update the referenced data value</div>
<div class="line">wait_until_some_subscription_received();</div>
<div class="line">assert(*data == 2.0);</div>
</div><!-- fragment --><h1>Translators</h1>
<p >The translation module provides functions to convert between ROS2 and state_representation data types.</p>
<h2>Message Translators</h2>
<p >As described in the Communication section, the ROS framework uses specific message formats to send data between applications. Wrapping and unwrapping the data values to and from the ROS message is handled by the message translators.</p>
<p >The message readers set the value of a particular data type from the corresponding ROS message instance.</p>
<p >The message writers format the value of a data type into the corresponding ROS message instance.</p>
<h2>Parameter Translators</h2>
<p >Conceptually, parameters are a way to label and transfer data with a name-value relationship. A parameter has a name and a data value of a particular data type. On an interface level, this allows parameter values to be retrieved or written by name in order to determine or configure the behaviour of particular elements.</p>
<p >The ROS <code>Parameter</code> is a specific implementation of the parameter concept which, together with the <code>ParameterMessage</code>, can be used to read and write named parameters on application nodes through the ROS interface. The ROS <code>Parameter</code> supports only simple types (atomic types, strings and arrays).</p>
<p >The control libraries <a href="https://epfl-lasa.github.io/control-libraries/versions/main/classstate__representation_1_1_parameter_interface.html"><code>state_representation::Parameter</code></a> is another implementation that supports more data types, including <code>State</code>-derived objects and matrices.</p>
<p >The parameter translator utilities in <code><a class="el" href="namespacemodulo__core_1_1translators.html" title="Modulo Core translation module for converting between ROS2 and state_representation data types.">modulo_core::translators</a></code> convert between ROS and <code>state_representation</code> parameter formats, so that parameters can be sent on the ROS interface but consumed as <code>state_representation</code> objects locally. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
